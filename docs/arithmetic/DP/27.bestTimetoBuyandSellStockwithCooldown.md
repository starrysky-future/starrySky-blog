---
tag:
  - 动态规划
categories:
  - 算法
recommend: 27
---

# 27.最佳买卖股票时机含冷冻期

[力扣题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

## 题目

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

**提示：**

- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`

## 思路

### 1.确定 dp 数组以及下标的含义

dp\[i][j]，第 i 天状态为 j，所剩的最多现金为 dp\[i][j]。

可以分为四个状态：

- 不持有股票可以分为两种

  - 状态一：保持卖出的状态（两天之前就卖出，昨天是冻结期）
  - 状态二：今天卖出股票

- 状态三：持有股票（今天买入，或是之前就买入了）

- 状态四：今天是冻结期

### 2.确定递推公式

**状态一**：dp\[i][0]有两种情况

- 昨天就保持卖出的状态，dp\[i-1][0]
- 昨天是冻结期，dp\[i-1][3]

dp\[i][0] = Math.max(dp\[i - 1][0], dp\[i - 1][3]);

**状态二**：dp\[i][1]只有一种情况，那就是昨天持有股票

dp\[i][1] = dp\[i - 1][2] + prices[i];

**状态三**：dp\[i][2]有三种情况

- 昨天就持有股票，dp\[i - 1][2]
- 昨天是保持卖出的状态的，今天买入了，dp\[i - 1][0] - prices[i]
- 昨天是冻结期，今天可以买入了，dp\[i - 1][3] - prices[i]

**状态四**：dp\[i][3]只有一种情况，那就是昨天卖出股票

dp\[i][3] = dp\[i - 1][1]

### 3.dp 数组如何初始化

持有股票需要付出对应的现金：dp\[0][2] = -prices[0]

没有持有股票的就初始化为 0：

- dp\[0][0] = 0

- dp\[0][1] = 0

- dp\[0][3] = 0

### 4.确定遍历顺序

dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。

### 5.举例推导 dp 数组

输入[1,2,3,0,2]

| 下标（第几天） | 股票价格 | 状态 j | 0   | 1   | 2   | 3   |
| -------------- | -------- | ------ | --- | --- | --- | --- |
| 0              | 1        |        | -1  | 0   | 0   | 0   |
| 1              | 2        |        | -1  | 0   | 1   | 0   |
| 2              | 3        |        | -1  | 0   | 2   | 1   |
| 3              | 0        |        | -1  | 1   | -1  | 2   |
| 4              | 2        |        | -1  | 2   | 3   | -1  |

## 代码

```js
var maxProfit = function (prices) {
  const n = prices.length;
  const dp = new Array(n).fill(0).map(() => new Array(4).fill(0));

  dp[0][0] = 0; // 持续没有持有股票
  dp[0][1] = 0; // 今天卖出
  dp[0][2] = -prices[0]; // 持有股票
  dp[0][3] = 0; // 冻结期

  for (let i = 1; i < n; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][3]);
    dp[i][1] = dp[i - 1][2] + prices[i];
    dp[i][2] = Math.max(
      dp[i - 1][2],
      dp[i - 1][0] - prices[i],
      dp[i - 1][3] - prices[i]
    );
    dp[i][3] = dp[i - 1][1];
  }
  return Math.max(dp[n - 1][0], dp[n - 1][1], dp[n - 1][3]);
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)
